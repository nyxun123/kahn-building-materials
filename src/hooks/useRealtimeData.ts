import { useEffect, useState, useCallback } from 'react';
import { supabase, checkConnection, initializeDatabase } from '@/lib/supabase';
import type { Database } from '@/lib/database.types';

type Product = Database['public']['Tables']['products']['Row'];
type ContactMessage = Database['public']['Tables']['contact_messages']['Row'];
type PageContent = Database['public']['Tables']['page_contents']['Row'];

interface UseRealtimeDataOptions {
  tableName: string;
  filters?: Record<string, any>;
  orderBy?: { column: string; ascending?: boolean };
  limit?: number;
}

export function useRealtimeData<T>({ 
  tableName, 
  filters = {}, 
  orderBy = { column: 'created_at', ascending: false },
  limit = 100 
}: UseRealtimeDataOptions) {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<string>('ÂàùÂßãÂåñ...');

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setConnectionStatus('ËøûÊé•Êï∞ÊçÆÂ∫ì...');

      // È™åËØÅÊï∞ÊçÆÂ∫ìËøûÊé•
      const health = await checkConnection();
      if (!health.success) {
        setConnectionStatus(`ËøûÊé•Â§±Ë¥•: ${health.error}`);
        throw new Error(`Êï∞ÊçÆÂ∫ìËøûÊé•Â§±Ë¥•: ${health.error}`);
      }

      setConnectionStatus('Êü•ËØ¢Êï∞ÊçÆ‰∏≠...');

      let query = supabase
        .from(tableName)
        .select('*')
        .limit(limit);

      // Â∫îÁî®ËøáÊª§Êù°‰ª∂
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          query = query.eq(key, value);
        }
      });

      // Â∫îÁî®ÊéíÂ∫è
      query = query.order(orderBy.column, { ascending: orderBy.ascending });

      const { data: result, error: fetchError } = await query;

      if (fetchError) {
        console.error(`‚ùå Âä†ËΩΩ${tableName}Â§±Ë¥•:`, fetchError);
        setConnectionStatus(`Êü•ËØ¢Â§±Ë¥•: ${fetchError.message}`);
        throw new Error(`Âä†ËΩΩÂ§±Ë¥•: ${fetchError.message} (${fetchError.code || 'Êú™Áü•ÈîôËØØ'})`);
      }

      const finalData = result || [];
      setData(finalData);
      setError(null);
      setConnectionStatus(`ÊàêÂäüÂä†ËΩΩ ${finalData.length} Êù°ËÆ∞ÂΩï`);
      
      console.log(`‚úÖ ${tableName} Êï∞ÊçÆÂä†ËΩΩÊàêÂäü: ${finalData.length} Êù°ËÆ∞ÂΩï`);
      
    } catch (err) {
      console.error(`‚ùå Ëé∑Âèñ${tableName}Êï∞ÊçÆÂ§±Ë¥•:`, err);
      setError(err as Error);
      setConnectionStatus(`ÈîôËØØ: ${(err as Error).message}`);
    } finally {
      setLoading(false);
    }
  }, [tableName, filters, orderBy, limit]);

  useEffect(() => {
    // ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìËøûÊé•
    initializeDatabase().then(({ connected, products }) => {
      if (connected) {
        setConnectionStatus(`ÂàùÂßãÂåñÊàêÂäüÔºåÊâæÂà∞ ${products.length} ‰∏™‰∫ßÂìÅ`);
      } else {
        setConnectionStatus('ÂàùÂßãÂåñÂ§±Ë¥•');
      }
    });

    // ÂàùÂßãÂä†ËΩΩÊï∞ÊçÆ
    fetchData();

    // ËÆæÁΩÆÂÆûÊó∂ËÆ¢ÈòÖ
    let channel: any = null;
    
    try {
      channel = supabase
        .channel(`${tableName}_changes`)
        .on(
          'postgres_changes',
          { event: '*', schema: 'public', table: tableName },
          (payload) => {
            console.log(`üîÑ ${tableName} ÂÆûÊó∂Êõ¥Êñ∞:`, payload.eventType);
            
            switch (payload.eventType) {
              case 'INSERT':
                setData(prev => [payload.new as T, ...prev]);
                break;
              case 'UPDATE':
                setData(prev => prev.map(item => 
                  (item as any).id === payload.new.id ? payload.new as T : item
                ));
                break;
              case 'DELETE':
                setData(prev => prev.filter(item => (item as any).id !== payload.old.id));
                break;
            }
          }
        )
        .subscribe((status) => {
          console.log(`üì° ${tableName} ËÆ¢ÈòÖÁä∂ÊÄÅ:`, status);
        });
    } catch (error) {
      console.error(`‚ùå ${tableName} ËÆ¢ÈòÖÂ§±Ë¥•:`, error);
    }

    return () => {
      if (channel) {
        supabase.removeChannel(channel);
      }
    };
  }, [tableName, fetchData]);

  const refetch = useCallback(() => {
    setConnectionStatus('ÈáçÊñ∞Âä†ËΩΩ...');
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch, connectionStatus };
}

// ‰∏ìÁî®hooks
export function useProducts(filters?: Record<string, any>) {
  return useRealtimeData<Product>({ 
    tableName: 'products', 
    filters,
    orderBy: { column: 'sort_order', ascending: true }
  });
}

export function useContactMessages(filters?: Record<string, any>) {
  return useRealtimeData<ContactMessage>({ 
    tableName: 'contact_messages', 
    filters,
    orderBy: { column: 'created_at', ascending: false }
  });
}

export function usePageContents(filters?: Record<string, any>) {
  return useRealtimeData<PageContent>({ 
    tableName: 'page_contents', 
    filters,
    orderBy: { column: 'page_key', ascending: true }
  });
}